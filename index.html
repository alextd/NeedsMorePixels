<html>
<head>
    <style>
html,body{
	position: relative; 
    margin:0;
    height:100%;
    max-width: 100%;
    overflow-x: hidden;
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}
::-webkit-scrollbar {
  display: none;
}
canvas {
    margin:0;
		//All these seem pointless but whatever
    image-rendering: optimizeSpeed;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: -o-crisp-edges;
    image-rendering: crisp-edges;
    -ms-interpolation-mode: nearest-neighbor;
}

.container
{
  background: #000;
  position:relative;
  height:100%;
  width:100%;
  margin:0 auto;
	}

.container img {
  position:absolute;
  left:0;
  -webkit-transition: opacity 1s ease-in-out;
  -moz-transition: opacity 1s ease-in-out;
  -o-transition: opacity 1s ease-in-out;
  transition: opacity 1s ease-in-out;
}

.container img:hover {
  opacity:0;
}
    </style>
</head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">



<body>
<div>
	<center>
	<div class="container">
		<canvas id="canvas" width="100" height="100" onclick="pixelateNext()"></canvas>
	</div>
	<input type="range" min="1" max="10" value="1" class="slider" id="myRange" style="width:95%"><br>
	<input type="file" name="media_file" id="fileIn" accept="image/*"><br>
	<input @click="clearURL()" type="text" id="urlIn" placeholder="Image URL">
	<button onclick="URLGO()">GO</button><br>
	<h1>Needs More Pixels</h1>
	<p style="white-space: pre-line">
	(The game from <a href="https://www.youtube.com/channel/UCVQa3eDp9rFpKw3LZ3AsMCg">Um, Actually</a>)
	Click image to step to the next clearer image.
	Arrow keys also work: up to start, down to end, left/right step one by one.
	Select a local image, or paste a URL to play new game.

	Known weird issue - the pixel colors for earlier steps change after you visit later steps. WHAT.
	</p>
	<text id="xsize"></text>x<text id="ysize"></text> pixels! Ratio = <text id="ratio"></text>
	</center>
</div>
<script>
var url = document.getElementById("urlIn");
var file = document.getElementById("fileIn");
var slider = document.getElementById("myRange");
var canvas = document.getElementById('canvas');
var xsize = document.getElementById('xsize');
var ysize = document.getElementById('ysize');
var ratio = document.getElementById('ratio');

addEventListener("load", function() {
    window.scrollTo(1, 0);
}, false);

// Chunks of this code:
// (C) Ken Fyrstenberg, Epistemex, License: CC3.0-attr
var ctx = canvas.getContext('2d'),
    img = new Image();
// wait until image is actually available
img.onload = start;

// resize the canvas to fill browser window dynamically
window.addEventListener('resize', resizeCanvas, false);
			
function resizeCanvas() {
	canvas.width = window.innerWidth*8;//Mobile scales pixels down so we scale this up so full-res image is closer to correct.
	canvas.height = window.innerHeight*8;
	canvas.style = `width: ${window.innerWidth}px;  height: ${window.innerHeight}px`;

	xsize.innerHTML = canvas.width
	ysize.innerHTML = canvas.height
	ratio.innerHTML = window.devicePixelRatio || 1

	findScale();
	pixelateCur(); 
}



// turn off image smoothing - this will give the pixelated effect
ctx.imageSmoothingQuality  = "high"
function setSmooth(on)
{
	ctx.mozImageSmoothingEnabled = on;
	ctx.webkitImageSmoothingEnabled = on ;
	ctx.imageSmoothingEnabled = on;
}

function start()
{
  document.body.scrollTop = 0; // For Safari
  document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
	
	resizeCanvas();
	findScale();
	pixelateFirst();
}
//img.onerror = function() {console.log("err")}//Still spams console oh well
//img.onabort = function() {console.log("abort")}

//Figure out scaling:
var w = canvas.width;
var h = canvas.height;
var imScale = 1;
var dx = 0, dy = 0;

function findScale()
{
	w = img.width;
	h = img.height;
	if(w/h > canvas.width/canvas.height)
	{	//canvas is taller 
		imScale = canvas.width/w;
		h = Math.floor(h*imScale);
		w = canvas.width;
		dx = 0;
		dy = Math.floor((canvas.height-h)/2);
	}
	else
	{ //image is taller
		imScale = canvas.height/h;
		w = Math.floor(w*imScale);
		h = canvas.height;
		dy = 0;
		dx = Math.floor((canvas.width-w)/2);
	}
}


img.src = 'http://www.councilofelrond.com/albums/album13/C_One_01.jpg';

function pixelateCur()		{	pixelate(slider.value)}
function pixelate(x) {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	if(x == 10)
	{
		setSmooth(true);
		ctx.drawImage(img, dx, dy, img.width*imScale, img.height*imScale);
		return;
	}

	var pixelatedH = 6-x+x*x,
	    pixelatedW = w * pixelatedH/h,
			blur = h/pixelatedH/4;
	if(h>w)
	{
		//taller than square
		pixelatedW = 6-x+x*x
		pixelatedH = h * pixelatedW/w
		blur = w/pixelatedW/4;
	}
	
	// draw original image, blurred
	// TODO: This should be its own context/image data?
	ctx.drawImage(img, 0, 0, w, h);//Draw it first so the blurred-out edges have a colorful backdrop
	ctx.filter = `blur(${blur}px)`;//TODO omg safari doesn't support this.
	ctx.drawImage(img, 0, 0, w, h);
	ctx.filter = 'blur(0px)';
	
	// draw to the scaled size
	// Minor stretching from ceil() shouldn't be noticable with the pixelation
	setSmooth(true);//Smooth down-scaling
	ctx.drawImage(canvas, 0, 0, w, h, 0, 0, Math.ceil(pixelatedW), Math.ceil(pixelatedH))
	
	
	setSmooth(false);//Pixelated up-scaling
	
	//Nudge for a tiny pixel overflow
	var nudgeX = pixelatedW%1 > 0 ? (1-(pixelatedW%1))/2 : 0
	var nudgeY = pixelatedH%1 > 0 ? (1-(pixelatedH%1))/2 : 0

	// then draw that scaled image thumb back to fill canvas
	// As smoothing is off the result will be pixelated
	ctx.drawImage(canvas, nudgeX, nudgeY, pixelatedW, pixelatedH, dx, dy, w, h);
	
	// Clear out the working area
	ctx.clearRect(0, 0, canvas.width, dy);
	ctx.clearRect(0, 0, dx, canvas.height);
}

URLGO = function() {
	img.src = urlIn.value;
	urlIn.value = "";
}

file.onchange = function(e) { 
 var tgt = e.target || window.event.srcElement;
 var files = tgt.files;

	// FileReader support
	if (FileReader && files && files.length) {
		var fr = new FileReader();
		fr.onload = function () {
			img.src = fr.result;
			file.value = ""
		}
		fr.readAsDataURL(files[0]);
	}

	// Not supported
	else {
			// fallback -- perhaps submit the input to an iframe and temporarily store
			// them on the server until the user's session ends.
	}
			
};

slider.oninput = function() {
	pixelateCur();
}
//Some keyboard commands:

//Paste
/*
window.addEventListener('paste', (event) => {
    console.log('paste action initiated')
		console.log(event.originalEvent.clipboardData)
});
*/

//Enter Key:
document.querySelector("#urlIn").addEventListener("keyup", event => {
    if(event.key !== "Enter") return; // Use `.key` instead.
    URLGO(); // Things you want to do.
    event.preventDefault(); // No need to `return false;`.
});

//Arrow Keys:
document.onkeydown = checkKey;

function checkKey(e) {

    e = e || window.event;

    if (e.keyCode == '38') {
			pixelateFirst(); event.preventDefault();
        // up arrow
    }
    else if (e.keyCode == '40') {
			pixelateLast(); event.preventDefault();
        // down arrow
    }
    else if (e.keyCode == '37') {
			pixelatePrev(); event.preventDefault();
       // left arrow
    }
    else if (e.keyCode == '39') {
			pixelateNext(); event.preventDefault();
       // right arrow
    }

}

function pixelateFirst()	{	slider.value = 1;pixelateCur()}
function pixelateLast()		{	slider.value = 10;pixelateCur()}
function pixelatePrev()		{	slider.value --;pixelateCur()}
function pixelateNext()		{	slider.value ++ ;pixelateCur()}



resizeCanvas();
</script>
</body>
</html>